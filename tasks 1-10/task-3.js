const MathX = (() => {
  // Функция для вычисления N-го числа в ряду Фибоначчи
  const fibonacci = (n) => {
    // Если число 1 или 0, то оно будет соответствовать своему порядковому номеру в ряду
    if (n <= 1) return n;
    // Если число n больше 1, то базовое условие не выполняется, мы переходим к следующему шагу.

    // Рассмотрим на примере n = 13. Базовое условие не выполняется и функция вызывает себя дважды
    // для значений fibonacci(12) и fibonacci(11), где при каждом вызове вызове также проверяется -
    // if (n <= 1) return n; до того момента пока не будет удовлетворять условию.

    // Поэтому:
    // - При вызове fibonacci(10) будет рассчитана сумма fibonacci(9) и fibonacci(8)
    // - При вызове fibonacci(9) будет рассчитана сумма fibonacci(8) и fibonacci(7) и так далее.
    // Когда базовый случай достигнут, идет так называемая "размотка" стека рекурсии,
    // возвращая значения на каждом уровне рекурсии

    // В итоге fibonacci(13) вернет сумму fibonacci(12) и fibonacci(11), которая будет рассчитана
    // как сумма предадущих чисел в ряду fibonacci, что будет являться 233.

    return fibonacci(n - 1) + fibonacci(n - 2);
  };

  // Функция для вычисления всех чисел в ряду Фибоначчи до числа N
  const fibonacciSeries = (n) => {
    // Создаем пустой массив
    const series = [];
    // Создаем цикл, который будет перебираться до числа n, прибавляя единицу на каждой итерации
    for (let i = 0; i <= n; i++) {
      // Пушим в массив отформатированные под ряд fibonacci числа
      series.push(fibonacci(i));
    }
    // Возвращаем массив
    return series;
  };

  // Функция для проверки, является ли число простым
  const isPrime = (num) => {
    // Если число меньше единицы - false
    if (num <= 1) {
      return false;
      // Если число 2 или 3 - true, так как они простые
    } else if (num <= 3) {
      return true;
    }

    // *Math.sqrt возвращает корень из числа, и если оно отрицательное, то NaN*
    // Проверяем, является ли число num делителем числа i от 2 до корня из num.
    // Если находится делитель, функция возвращает false, так как число num не является простым.
    for (let i = 2; i <= Math.sqrt(num); i++) {
      if (num % i === 0) return false;
    }
    return true;
  };

  // Функция для вычисления всех простых чисел до числа N
  const primeNumber = (n) => {
    // Создаем переменную count и присваиваем ей значение 0.
    // Она будет отслеживать количество уже найденных простых чисел.
    let count = 0;
    // Создаем переменную num и присваиваем ей значение 2.
    // Она будет увеличиваться на 1 на каждой итерации цикла и проверяться на простоту.
    let num = 2;
    // Используем цикл while, который продолжается до тех пор, пока count не станет равным n.
    // Это будет означать, что мы нашли достаточное количество простых чисел.
    while (count < n) {
      // Проверяем, является ли число простым и если да, прибавляем count и num единицу.
      if (isPrime(num)) {
        count++;
      }
      num++;
    }
    // При возвращении числа num вычитаем 1, так как последнюю итерацию учитывать не нужно.
    return num - 1;
  };

  // И в конце возвращаем объект из функций
  return {
    fibonacci,
    fibonacciSeries,
    isPrime,
    primeNumber,
  };
})();

export default MathX;
